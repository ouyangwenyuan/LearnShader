# shader 学习笔记

Shader 可以做什么？ 可以渲染游戏模型，模拟波动的海面，实现各种屏幕特效，学习目标，如何让Shader 和其他游戏开发元素（模型，纹理，脚本等）相结合，实现游戏中常见的渲染效果。

## 第二章 渲染流水线
渲染流水线 就是从一个三维场景触发，生成（或者渲染成）一张2的图像的过程，换句话说，计算机需要从一系列顶点数据，纹理信息出发，把这些信息转化成人眼可以看到的图像。这个工作通常有cpu 和 GPU共同完成。
应用阶段-》几何阶段-》光栅化阶段
应用阶段输出渲染图元 ，几何阶段输出屏幕控件的顶点信息
应用阶段开发者具有绝对的控制权，在这一阶段，开发者有三个主要任务，1、准备好场景数据，例如摄像机的位置，视椎体，场景中包括哪些模型，使用了哪些光源，2、为了提高渲染性能，我们往往需要做一个粗粒度的剔除工作，把哪些不可见的物体剔除。
3、我们需要设置好每个模型的渲染状态，这些渲染状态包括但不限于它使用的材质（漫反射颜色，高光反射颜色）使用的纹理，使用的Shader等。这一阶段最重要的输出是渲染所需的几何信息即渲染图元，渲染图元可以是点，线，三角面等。这些信息奖传递给几何阶段。


几何阶段用于处理所有和我们需要绘制的几何相关的事情，例如，决定需要绘制图元是什么，怎么绘制它们，在哪里绘制它们，这一阶段在GPU完成。这一阶段负责和每个图元打交道，进行逐顶点，逐多边形的操作，可以进一步分成更小的流水线阶段，这一阶段最重要的任务就是把顶点坐标
变换到屏幕空间中， 再交给光栅器进行处理，然后输出屏幕空间的二维顶点作弊，每个顶点对应的深度值，着色信息。

光栅化阶段将会使用上一阶段传递的数据来产生屏幕上的像素，并渲染最终的图像，这一阶段也是在gpu上运行，光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制到屏幕上，它需要对上一阶段的逐顶点数据（纹理坐标，顶点颜色）进行插值，然后再进行逐像素化处理。

应用阶段大致分三个步骤，1、把数据加载到显存，2、设置渲染状态 3、调用Draw call。
1、所有渲染需要的数据都需要重硬盘加载到内存中，然后网格和纹理数据又被加载到显存中，这是因为，显卡对显存的访问速度更快，而且大多数显卡对系统内存美欧直接访问的权限，当数据加载到显存之后，内存中的数据就可以移除了，但对于一些数据来说，cpu 仍然需要访问它们，比如
访问网格数据做碰撞检测。

设置渲染状态
什么事渲染状态，一个通俗的解释就是这些状态定义了场景中的网格是怎么被渲染的。如果没有更改渲染状态，那么所有的网格都将使用同一种渲染状态。在准备好上述工作后，cpu将调用一个渲染命令来告诉cpu进行渲染，这个命令就是Drawcall。
Draw call 就是一个命令，它的发起方是cpu，接收方是gpu，之歌命令仅仅指向一个需要被渲染的图元列表，而不会再包含任何材质信息，当给定一个draw call 是，gpu 就会根据渲染状态（材质，纹理，着色器等）和所有输入的顶点进行计算，最终输出成屏幕需要显示的像素。

GPU流水线
GPU的渲染过程就是GPU流水线。
对于概念阶段的后俩个阶段，即几何阶段和光栅阶段，开发者无法拥有绝对的控制权，其实现的载体是gpu，gpu通过实现流水线化，大大加快渲染速度。虽然我们无法完全控制这俩阶段的实现细节，但gpu向开发者开发了很多控制权。
几何阶段和光栅阶段又可分成若干个小的流水线，这些流水线有gpu实现，每个阶段提供了不同的可配置和可编程的阶段。

几何阶段流水线
顶点数据 -- 》顶点着色器（必须由开发者编程）-》曲面细分着色器（可编程可选）-》几何着色器（可编程可选）-》裁剪（可配置）-》 屏幕映射-》

光栅阶段流水线
三角形设置 -》 三角形遍历 -》片元着色器（可编程，可选）-》逐片元操作（可配置）-》 输出屏幕像素图像

顶点着色器是流水线的第一个阶段，它的输入来着cpu，处理的单位是顶点，也就是输入进来的每个顶点都会调用一次顶点着色器，顶点着色器本身不可以创建或者销毁任何顶点，而且无法获得顶点和顶点之间的关系，正因为这样相互独立GPU可以利用本身的特性并行处理每一个顶点。
顶点着色器完成的主要工作有，坐标变换和逐顶点光照，输出下一阶段所需的数据，gpu在每个输入的网格顶点上都会调用顶点着色器，顶点着色器必须进行顶点坐标变换，需要时还需要计算合输出顶点的颜色，坐标变换就是把顶点坐标从模型空间转换到齐次裁剪空间，顶点着色器可以再这一步
中改变顶点的位置，这个再顶点动画中非常有用。，用于进行逐顶点光照。我们可以通过改变顶点的位置来模拟水面，布料等

o.pos = mul(UNITY_MVP, v.position); // 把顶点坐标从模型空间转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标（Nomalized Device coordinates，NDC)
注意NDC的坐标范围是opengl 也是Unity使用的NDC z分量是【-1,1】而在directx 中NDC z分量是【0,1】

裁剪（clipping）只有在单位立方体内的图元才需要继续处理，不在立方体内的会被裁剪，新的顶点会被生成，原来外部的顶点会被舍弃。

屏幕映射
这一步输入的坐标仍然是三维坐标系下的坐标（范围在单位立方体内）屏幕映射的任务就是把每个图元的x和y坐标转换到屏幕坐标系下，屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大的关系。
那么输入的z坐标会怎么样呢，屏幕映射不会对输入的z坐标做任何处理，实际上，屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系（Window coordinates).这些值会一起传递到光栅化阶段。

有一个需要引起注意的地方是，屏幕坐标系在open gl  和 directx 之间的差异，open gl把屏幕左下角当成原点，而direct 则定义屏幕的左上角当成原点坐标。不管原因如何，差异就是造成了，留给开发者的就是，时刻需要小心这样的差异，如果你发现得到的图像是倒转的，那很可能就是这个原因造成的。

三角形遍历
这个阶段会检查每个像素是否被一个三角网格所覆盖，如果被覆盖，就会生成一个片元，而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也叫扫描变换。片元中的状态是对三个顶点的信息进行插值得到的。一个片元并不是真正意义的像素，而是包含很多状态的集合。
这些状态用于计算每个像素的最终颜色，这些状态包括但不限于它的屏幕坐标，深度信息，已经顶点信息，法线，纹理坐标。

片元着色器
这是另一个非常重要的可编程着色器阶段，在direct x 中片元着色器被称为像是着色器（pixel shader），前面的光栅化实际不会影响屏幕上每个像素的颜色值，而是会产生一系列数据信息，用来表述一个三角网格是怎样覆盖每个像素，而每个片元就负责存储这样一系列数据。
真正对像素产生影响的是逐片元操作，这一阶段最重要的技术之一就是纹理采样，为了再片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后光栅化阶段对三角形网格的三个顶点的纹理坐标进行插值，就可以得到片元的纹理坐标了。